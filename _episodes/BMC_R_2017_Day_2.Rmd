---
title: "The Brain & Mind Centre"
author: "Sydney Informatics Hub"
subtitle: Day 2
output:
  html_document:
    hightlight: github
    theme: lumen
    toc: yes
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = FALSE)
```

## Controls & Loops

These allow you to control the flow of execution of a script typically inside of a function. Common ones include:

* if, else
* for
* while
* repeat
* break
* next
* function

### If loop
```{r, eval=FALSE, message=FALSE}

if (condition) {
    # do something
} else {
    # do something else
}

```

e.g.

```{r}
x=1
if(x > 1) {
  print("x is greater than 1")
  } else {
    print("x is less than 1")
  } 
```

### For loops

A for loop works on an iterable variable and assigns successive values till the end of a sequence.

```{r}
for (i in 1:10) {
    print(i)
}

```

```{r}
x <- c("apples", "oranges", "bananas", "strawberries")

for (i in 1:4) {
    print(x[i])
}

for (i in seq(x)) {
    print(x[i])
}

for (i in 1:4) print(x[i])
```

### While loop
```{r}
i <- 1
while (i < 10) {
    print(i)
    i <- i + 1
}
```

Be sure there is a way to exit out of a while loop.

### Repeat Loops

The repeat loop is an infinite loop and used in association with a break statement.

```{r}
a = 1
repeat { 
  print(a) 
  a = a+1 
  if(a > 4) break }

```

### Break statement

A break statement is used in a loop to stop the iterations and flow the control outside of the loop.

```{r}
x = 1:10 
 for (i in x){ 
     if (i == 2){ 
         break 
     }
     print(i)
 }
```

### Next statement

Next statement enables to skip the current iteration of a loop without terminating it.

```{r}
x = 1: 4 
 for (i in x) { 
     if (i == 2){ 
         next}
     print(i)
 }
```

### Function

If you have to repeat the same few lines of code more than once, then you really need to write a function. Functions are a fundamental building block of R. You use them all the time in R and it's not that much harder to string functions together (or write entirely new ones from scratch) to do more.

* R functions are objects just like anything else.
* By default, R function arguments are lazy - they're only evaluated if they're actually used:
* Every call on a R object is almost always a function call.

#### Basic components of a function

* The body(), the code inside the function.
* The formals(), the "formal" argument list, which controls how you can call the function.
* The `environment()`` which determines how variables referred to inside the function are found.
* args() to list arguments.

```{r}
# Addition 
add <- function(a, b) {
    return(a + b)
}

add(2,5)
```

#### Examples from gambling dataset



Adapted from :

https://ramnathv.github.io/pycon2014-r/learn/controls.html

https://www.r-bloggers.com/control-structures-loops-in-r/
